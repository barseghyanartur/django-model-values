{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Provides Django model utilities for encouraging direct data access instead of unnecessary object overhead. Implemented through compatible method and operator extensions 1 to QuerySets and Managers . The primary motivation is the experiential observation that the active record pattern - specifically Model.save - is the root of all evil. The secondary goal is to provide a more intuitive data layer, similar to PyData projects such as pandas . Usage: instantiate the custom manager in your models. Updates The Bad : book = Book.objects.get(pk=pk) book.rating = 5.0 book.save() This example is ubiquitous and even encouraged in many django circles. It's also an epic fail: Runs an unnecessary select query, as no fields need to be read. Updates all fields instead of just the one needed. Therefore also suffers from race conditions. And is relatively verbose, without addressing errors yet. The solution is relatively well-known, and endorsed by django's own docs , but remains under-utilized. The Ugly : Book.objects.filter(pk=pk).update(rating=5.0) So why not provide syntactic support for the better approach? The Manager supports filtering by primary key, since that's so common. The QuerySet supports column updates. The Good : Book.objects[pk]['rating'] = 5.0 But one might posit... \"Isn't the encapsulation save provides worth it in principle?\" \"Doesn't the new update_fields option fix this in practice?\" \"What if the object is cached or has custom logic in the save method?\" No, no, and good luck with that. 2 Consider a more realistic example which addresses these concerns. The Bad : try: book = Book.objects.get(pk=pk) except Book.DoesNotExist: changed = False else: changed = book.publisher != publisher if changed: book.publisher = publisher book.pubdate = today book.save(update_fields=['publisher', 'pubdate']) This solves the most severe problem, though with more verbosity and still an unnecessary read. 3 Note handling pubdate in the save implementation would only spare the caller one line of code. But the real problem is how to handle custom logic when update_fields isn't specified. There's no one obvious correct behavior, which is why projects like django-model-utils have to track the changes on the object itself. 4 A better approach would be an update_publisher method which does all and only what is required. So what would such an implementation be? A straight-forward update won't work, yet only a minor tweak is needed. The Ugly : changed = Book.objects.filter(pk=pk).exclude(publisher=publisher) \\ .update(publisher=publisher, pubdate=today) Now the update is only executed if necessary. And this can be generalized with a little inspiration from {get,update}_or_create . The Good : changed = Book.objects[pk].change({'pubdate': today}, publisher=publisher) Selects Direct column access has some of the clunkiest syntax: values_list(..., flat=True) . QuerySets override __getitem__ , as well as comparison operators for simple filters. Both are common syntax in panel data layers. The Bad : {book.pk: book.name for book in qs} (book.name for book in qs.filter(name__isnull=False)) if qs.filter(author=author): The Ugly : dict(qs.values_list('pk', 'name')) qs.exclude(name=None).values_list('name', flat=True) if qs.filter(author=author).exists(): The Good : dict(qs['pk', 'name']) qs['name'] != None if author in qs['author']: Aggregation Once accustomed to working with data values, a richer set of aggregations becomes possible. Again the method names mirror projects like pandas whenever applicable. The Bad : collections.Counter(book.author for book in qs) sum(book.rating for book in qs) / len(qs) counts = collections.Counter() for book in qs: counts[book.author] += book.quantity The Ugly : dict(qs.values_list('author').annotate(model.Count('author'))) qs.aggregate(models.Avg('rating'))['rating__avg'] dict(qs.values_list('author').annotate(models.Sum('quantity'))) The Good : dict(qs['author'].value_counts()) qs['rating'].mean() dict(qs['quantity'].groupby('author').sum()) Expressions F expressions are similarly extended to easily create Q , Func , and OrderBy objects. Note they can be used directly even without a custom manager. The Bad : (book for book in qs if book.author.startswith('A') or book.author.startswith('B')) (book.title[:10] for book in qs) for book in qs: book.rating += 1 book.save() The Ugly : qs.filter(Q(author__startswith='A') | Q(author__startswith='B')) qs.values_list(functions.Substr('title', 1, 10), flat=True) qs.update(rating=models.F('rating') + 1) The Good : qs[F.any(map(F.author.startswith, 'AB'))] qs[F.title[:10]] qs['rating'] += 1 Conditionals Annotations and updates with Case and When expressions. See also bulk_changed and bulk_change for efficient bulk operations on primary keys. The Bad : collections.Counter('low' if book.quantity < 10 else 'high' for book in qs).items() for author, quantity in items: for book in qs.filter(author=author): book.quantity = quantity book.save() The Ugly : qs.values_list(models.Case( models.When(quantity__lt=10, then=models.Value('low')), models.When(quantity__gte=10, then=models.Value('high')), output_field=models.CharField(), )).annotate(count=models.Count('*')) cases = (models.When(author=author, then=models.Value(quantity)) for author, quantity in items) qs.update(quantity=models.Case(*cases, default='quantity')) The Good : qs[{F.quantity < 10: 'low', F.quantity >= 10: 'high'}].value_counts() qs['quantity'] = {F.author == author: quantity for author, quantity in items} The only incompatible changes are edge cases which aren't documented behavior, such as queryset comparison. \u21a9 In the vast majority of instances of that idiom, the object is immediately discarded and no custom logic is necessary. Furthermore the dogma of a model knowing how to serialize itself doesn't inherently imply a single all-purpose instance method. Specialized classmethods or manager methods would be just as encapsulated. \u21a9 Premature optimization? While debatable with respect to general object overhead, nothing good can come from running superfluous database queries. \u21a9 Supporting update_fields with custom logic also results in complex conditionals, ironic given that OO methodology ostensibly favors separate methods over large switch statements. \u21a9","title":"Introduction"},{"location":"#updates","text":"The Bad : book = Book.objects.get(pk=pk) book.rating = 5.0 book.save() This example is ubiquitous and even encouraged in many django circles. It's also an epic fail: Runs an unnecessary select query, as no fields need to be read. Updates all fields instead of just the one needed. Therefore also suffers from race conditions. And is relatively verbose, without addressing errors yet. The solution is relatively well-known, and endorsed by django's own docs , but remains under-utilized. The Ugly : Book.objects.filter(pk=pk).update(rating=5.0) So why not provide syntactic support for the better approach? The Manager supports filtering by primary key, since that's so common. The QuerySet supports column updates. The Good : Book.objects[pk]['rating'] = 5.0 But one might posit... \"Isn't the encapsulation save provides worth it in principle?\" \"Doesn't the new update_fields option fix this in practice?\" \"What if the object is cached or has custom logic in the save method?\" No, no, and good luck with that. 2 Consider a more realistic example which addresses these concerns. The Bad : try: book = Book.objects.get(pk=pk) except Book.DoesNotExist: changed = False else: changed = book.publisher != publisher if changed: book.publisher = publisher book.pubdate = today book.save(update_fields=['publisher', 'pubdate']) This solves the most severe problem, though with more verbosity and still an unnecessary read. 3 Note handling pubdate in the save implementation would only spare the caller one line of code. But the real problem is how to handle custom logic when update_fields isn't specified. There's no one obvious correct behavior, which is why projects like django-model-utils have to track the changes on the object itself. 4 A better approach would be an update_publisher method which does all and only what is required. So what would such an implementation be? A straight-forward update won't work, yet only a minor tweak is needed. The Ugly : changed = Book.objects.filter(pk=pk).exclude(publisher=publisher) \\ .update(publisher=publisher, pubdate=today) Now the update is only executed if necessary. And this can be generalized with a little inspiration from {get,update}_or_create . The Good : changed = Book.objects[pk].change({'pubdate': today}, publisher=publisher)","title":"Updates"},{"location":"#selects","text":"Direct column access has some of the clunkiest syntax: values_list(..., flat=True) . QuerySets override __getitem__ , as well as comparison operators for simple filters. Both are common syntax in panel data layers. The Bad : {book.pk: book.name for book in qs} (book.name for book in qs.filter(name__isnull=False)) if qs.filter(author=author): The Ugly : dict(qs.values_list('pk', 'name')) qs.exclude(name=None).values_list('name', flat=True) if qs.filter(author=author).exists(): The Good : dict(qs['pk', 'name']) qs['name'] != None if author in qs['author']:","title":"Selects"},{"location":"#aggregation","text":"Once accustomed to working with data values, a richer set of aggregations becomes possible. Again the method names mirror projects like pandas whenever applicable. The Bad : collections.Counter(book.author for book in qs) sum(book.rating for book in qs) / len(qs) counts = collections.Counter() for book in qs: counts[book.author] += book.quantity The Ugly : dict(qs.values_list('author').annotate(model.Count('author'))) qs.aggregate(models.Avg('rating'))['rating__avg'] dict(qs.values_list('author').annotate(models.Sum('quantity'))) The Good : dict(qs['author'].value_counts()) qs['rating'].mean() dict(qs['quantity'].groupby('author').sum())","title":"Aggregation"},{"location":"#expressions","text":"F expressions are similarly extended to easily create Q , Func , and OrderBy objects. Note they can be used directly even without a custom manager. The Bad : (book for book in qs if book.author.startswith('A') or book.author.startswith('B')) (book.title[:10] for book in qs) for book in qs: book.rating += 1 book.save() The Ugly : qs.filter(Q(author__startswith='A') | Q(author__startswith='B')) qs.values_list(functions.Substr('title', 1, 10), flat=True) qs.update(rating=models.F('rating') + 1) The Good : qs[F.any(map(F.author.startswith, 'AB'))] qs[F.title[:10]] qs['rating'] += 1","title":"Expressions"},{"location":"#conditionals","text":"Annotations and updates with Case and When expressions. See also bulk_changed and bulk_change for efficient bulk operations on primary keys. The Bad : collections.Counter('low' if book.quantity < 10 else 'high' for book in qs).items() for author, quantity in items: for book in qs.filter(author=author): book.quantity = quantity book.save() The Ugly : qs.values_list(models.Case( models.When(quantity__lt=10, then=models.Value('low')), models.When(quantity__gte=10, then=models.Value('high')), output_field=models.CharField(), )).annotate(count=models.Count('*')) cases = (models.When(author=author, then=models.Value(quantity)) for author, quantity in items) qs.update(quantity=models.Case(*cases, default='quantity')) The Good : qs[{F.quantity < 10: 'low', F.quantity >= 10: 'high'}].value_counts() qs['quantity'] = {F.author == author: quantity for author, quantity in items} The only incompatible changes are edge cases which aren't documented behavior, such as queryset comparison. \u21a9 In the vast majority of instances of that idiom, the object is immediately discarded and no custom logic is necessary. Furthermore the dogma of a model knowing how to serialize itself doesn't inherently imply a single all-purpose instance method. Specialized classmethods or manager methods would be just as encapsulated. \u21a9 Premature optimization? While debatable with respect to general object overhead, nothing good can come from running superfluous database queries. \u21a9 Supporting update_fields with custom logic also results in complex conditionals, ironic given that OO methodology ostensibly favors separate methods over large switch statements. \u21a9","title":"Conditionals"},{"location":"example/","text":"An example Model used in the tests. from django.db import models from model_values import F, Manager, classproperty class Book(models.Model): title = models.TextField() author = models.CharField(max_length=50) quantity = models.IntegerField() last_modified = models.DateTimeField(auto_now=True) objects = Manager() Table logic Django recommends model methods for row-level functionality, and custom managers for table-level functionality. That's fine if the custom managers are reused across models, but often they're just custom filters, and specific to a model. As evidenced by django-model-utils' QueryManager . There's a simpler way to achieve the same end: a model classmethod . In some cases a profileration of classmethods is an anti-pattern, but in this case functions won't suffice. It's Django that attached the Manager instance to a class. Additionally a classproperty wrapper is provided, to mimic a custom Manager or Queryset without calling it first. @classproperty def in_stock(cls): return cls.objects.filter(F.quantity > 0) Row logic Some of the below methods may be added to a model mixin in the future. It's a delicate balance, as the goal is to not encourage object usage. However, sometimes having an object already is inevitable, so it's still worth considering best practices given that situation. Providing wrappers for any manager method that's pk -based may be worthwhile, particularly a filter to match only the object. @property def object(self): return type(self).objects[self.pk] From there one can easily imagine other useful extensions. def changed(self, **kwargs): return self.object.changed(**kwargs) def update(self, **kwargs): for name in kwargs: setattr(self, name, kwargs[name]) return self.object.update(**kwargs)","title":"Example"},{"location":"example/#table-logic","text":"Django recommends model methods for row-level functionality, and custom managers for table-level functionality. That's fine if the custom managers are reused across models, but often they're just custom filters, and specific to a model. As evidenced by django-model-utils' QueryManager . There's a simpler way to achieve the same end: a model classmethod . In some cases a profileration of classmethods is an anti-pattern, but in this case functions won't suffice. It's Django that attached the Manager instance to a class. Additionally a classproperty wrapper is provided, to mimic a custom Manager or Queryset without calling it first. @classproperty def in_stock(cls): return cls.objects.filter(F.quantity > 0)","title":"Table logic"},{"location":"example/#row-logic","text":"Some of the below methods may be added to a model mixin in the future. It's a delicate balance, as the goal is to not encourage object usage. However, sometimes having an object already is inevitable, so it's still worth considering best practices given that situation. Providing wrappers for any manager method that's pk -based may be worthwhile, particularly a filter to match only the object. @property def object(self): return type(self).objects[self.pk] From there one can easily imagine other useful extensions. def changed(self, **kwargs): return self.object.changed(**kwargs) def update(self, **kwargs): for name in kwargs: setattr(self, name, kwargs[name]) return self.object.update(**kwargs)","title":"Row logic"},{"location":"reference/","text":"model_values.Lookup Mixin for field lookups. is_valid property readonly Whether field isvalid . __ge__ ( self , value ) special gte Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) __gt__ ( self , value ) special gt Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) __le__ ( self , value ) special lte Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) __lshift__ ( self , value ) special left Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) __lt__ ( self , value ) special lt Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) __ne__ ( self , value ) special ne Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) __rshift__ ( self , value ) special right Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) above ( self , value ) strictly_above Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) below ( self , value ) strictly_below Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) contained ( self , value ) contained Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) contains ( self , value , properly = False , bb = False ) Return whether field contains the value. Options apply only to geom fields. Parameters: Name Type Description Default properly contains_properly False bb bounding box, bbcontains False Source code in model_values/__init__.py def contains ( self , value , properly = False , bb = False ): \"\"\"Return whether field `contains` the value. Options apply only to geom fields. Args: properly: `contains_properly` bb: bounding box, `bbcontains` \"\"\" properly = '_properly' * bool ( properly ) bb = 'bb' * bool ( bb ) return self . __eq__ ( value , f '__ { bb } contains { properly } ' ) coveredby ( self , value ) coveredby Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) covers ( self , value ) covers Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) crosses ( self , value ) crosses Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) disjoint ( self , value ) disjoint Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) endswith ( self , value ) endswith Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) equals ( self , value ) equals Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) icontains ( self , value ) icontains Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) iendswith ( self , value ) iendswith Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) iexact ( self , value ) iexact Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) intersects ( self , value ) intersects Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) iregex ( self , value ) iregex Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) isin ( self , value ) in Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) istartswith ( self , value ) istartswith Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) left ( self , value ) left Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) overlaps ( self , geom , position = '' , bb = False ) Return whether field overlaps with geometry . Parameters: Name Type Description Default position overlaps_{left, right, above, below} '' bb bounding box, bboverlaps False Source code in model_values/__init__.py def overlaps ( self , geom , position = '' , bb = False ): \"\"\"Return whether field `overlaps` with geometry . Args: position: `overlaps_{left, right, above, below}` bb: bounding box, `bboverlaps` \"\"\" bb = 'bb' * bool ( bb ) return self . __eq__ ( geom , f '__ { bb } overlaps_ { position } ' . rstrip ( '_' )) range ( self , * values ) range Source code in model_values/__init__.py def range ( self , * values ): \"\"\"range\"\"\" return self . __eq__ ( values , '__range' ) regex ( self , value ) regex Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) relate ( self , * values ) relate Source code in model_values/__init__.py def relate ( self , * values ): \"\"\"relate\"\"\" return self . __eq__ ( values , '__relate' ) right ( self , value ) right Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) startswith ( self , value ) startswith Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) touches ( self , value ) touches Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup ) within ( self , geom , distance = None ) Return whether field is within geometry. Parameters: Name Type Description Default distance dwithin None Source code in model_values/__init__.py def within ( self , geom , distance = None ): \"\"\"Return whether field is `within` geometry. Args: distance: `dwithin` \"\"\" if distance is None : return self . __eq__ ( geom , '__within' ) return self . __eq__ (( geom , distance ), '__dwithin' ) Note Spatial lookups require gis to be enabled. model_values.F Create F , Q , and Func objects with expressions. F creation supported as attributes: F.user == F('user') , F.user.created == F('user__created') . Q lookups supported as methods or operators: F.text.iexact(...) == Q(text__iexact=...) , F.user.created >= ... == Q(user__created__gte=...) . Func objects also supported as methods: F.user.created.min() == Min('user__created') . __eq__ ( self , value , lookup = '' ) special Return Q object with lookup. Source code in model_values/__init__.py def __eq__ ( self , value , lookup : str = '' ) -> models . Q : \"\"\"Return ``Q`` object with lookup.\"\"\" if not lookup and type ( value ) is models . F : return self . name == value . name return models . Q ( ** { self . name + lookup : value }) __getattr__ ( self , name ) special Return new F _ object with chained attribute. Source code in model_values/__init__.py def __getattr__ ( self , name : str ) -> 'F' : \"\"\"Return new `F`_ object with chained attribute.\"\"\" return type ( self )( ' {} __ {} ' . format ( self . name , name )) __getitem__ ( self , slc ) special Return field Substr or Right . Source code in model_values/__init__.py def __getitem__ ( self , slc : slice ) -> models . Func : \"\"\"Return field ``Substr`` or ``Right``.\"\"\" assert ( slc . stop or 0 ) >= 0 and slc . step is None start = slc . start or 0 if start < 0 : assert slc . stop is None return functions . Right ( self , - start ) size = slc . stop and max ( slc . stop - start , 0 ) return functions . Substr ( self , start + 1 , size ) __ne__ ( self , value ) special Allow __ne=None lookup without custom queryset. Source code in model_values/__init__.py def __ne__ ( self , value ) -> models . Q : \"\"\"Allow __ne=None lookup without custom queryset.\"\"\" if value is None : return self . __eq__ ( False , '__isnull' ) return self . __eq__ ( value , '__ne' ) find ( self , sub , ** extra ) Return StrIndex with str.find semantics. Source code in model_values/__init__.py def find ( self , sub , ** extra ) -> models . Expression : \"\"\"Return ``StrIndex`` with ``str.find`` semantics.\"\"\" return functions . StrIndex ( self , Value ( sub ), ** extra ) - 1 ljust ( self , width , fill = ' ' , ** extra ) Return LPad with wrapped values. Source code in model_values/__init__.py def ljust ( self , width : int , fill = ' ' , ** extra ) -> models . Func : \"\"\"Return ``LPad`` with wrapped values.\"\"\" return functions . LPad ( self , width , Value ( fill ), ** extra ) log ( self , base = 2.718281828459045 , ** extra ) Return Log , by default Ln . Source code in model_values/__init__.py def log ( self , base = math . e , ** extra ) -> models . Func : \"\"\"Return ``Log``, by default ``Ln``.\"\"\" return functions . Log ( self , base , ** extra ) replace ( self , old , new = '' , ** extra ) Return Replace with wrapped values. Source code in model_values/__init__.py def replace ( self , old , new = '' , ** extra ) -> models . Func : \"\"\"Return ``Replace`` with wrapped values.\"\"\" return functions . Replace ( self , Value ( old ), Value ( new ), ** extra ) rjust ( self , width , fill = ' ' , ** extra ) Return RPad with wrapped values. Source code in model_values/__init__.py def rjust ( self , width : int , fill = ' ' , ** extra ) -> models . Func : \"\"\"Return ``RPad`` with wrapped values.\"\"\" return functions . RPad ( self , width , Value ( fill ), ** extra ) Note Since attributes are used for constructing F objects, there may be collisions between field names and methods. For example, name is a reserved attribute, but the usual constructor can still be used: F('name') . Note See source for available spatial functions if gis is configured. model_values.QuerySet __add__ ( self , value ) special add Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ ) __contains__ ( self , value ) special Return whether value is present using exists . Source code in model_values/__init__.py def __contains__ ( self , value ): \"\"\"Return whether value is present using ``exists``.\"\"\" if self . _result_cache is None and self . _flat : return ( self == value ) . exists () return value in iter ( self ) __eq__ ( self , value , lookup = '' ) special Return QuerySet _ filtered by comparison to given value. Source code in model_values/__init__.py def __eq__ ( self , value , lookup : str = '' ) -> 'QuerySet' : \"\"\"Return `QuerySet`_ filtered by comparison to given value.\"\"\" ( field ,) = self . _fields return self . filter ( ** { field + lookup : value }) __getitem__ ( self , key ) special Allow column access by field names, expressions, or F objects. qs[field] returns flat values_list qs[field, ...] returns tupled values_list qs[Q_obj] provisionally returns filtered QuerySet _ Source code in model_values/__init__.py def __getitem__ ( self , key ): \"\"\"Allow column access by field names, expressions, or ``F`` objects. ``qs[field]`` returns flat ``values_list`` ``qs[field, ...]`` returns tupled ``values_list`` ``qs[Q_obj]`` provisionally returns filtered `QuerySet`_ \"\"\" if isinstance ( key , tuple ): return self . values_list ( * map ( extract , key ), named = True ) key = extract ( key ) if isinstance ( key , ( str , models . Expression )): return self . values_list ( key , flat = True ) if isinstance ( key , models . Q ): return self . filter ( key ) return super () . __getitem__ ( key ) __iter__ ( self ) special Iteration extended to support :meth: groupby . Source code in model_values/__init__.py def __iter__ ( self ): \"\"\"Iteration extended to support :meth:`groupby`.\"\"\" if not hasattr ( self , '_groupby' ): return super () . __iter__ () size = len ( self . _groupby ) rows = self [ self . _groupby + self . _fields ] . order_by ( * self . _groupby ) . iterator () groups = itertools . groupby ( rows , key = operator . itemgetter ( * range ( size ))) getter = operator . itemgetter ( size if self . _flat else slice ( size , None )) if self . _named : Row = collections . namedtuple ( 'Row' , self . _fields ) getter = lambda tup : Row ( * tup [ size :]) # noqa return (( key , map ( getter , values )) for key , values in groups ) __mod__ ( self , value ) special mod Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ ) __mul__ ( self , value ) special mul Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ ) __pow__ ( self , value ) special pow Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ ) __setitem__ ( self , key , value ) special Update a single column. Source code in model_values/__init__.py def __setitem__ ( self , key , value ): \"\"\"Update a single column.\"\"\" self . update ( ** { key : value }) __sub__ ( self , value ) special sub Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ ) __truediv__ ( self , value ) special truediv Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ ) annotate ( self , * args , ** kwargs ) Annotate extended to also handle mapping values, as a Case _ expression. Parameters: Name Type Description Default **kwargs field={Q_obj: value, ...}, ... {} As a provisional feature, an optional default key may be specified. Source code in model_values/__init__.py def annotate ( self , * args , ** kwargs ) -> 'QuerySet' : \"\"\"Annotate extended to also handle mapping values, as a `Case`_ expression. Args: **kwargs: ``field={Q_obj: value, ...}, ...`` As a provisional feature, an optional ``default`` key may be specified. \"\"\" for field , value in kwargs . items (): if Case . isa ( value ): kwargs [ field ] = Case . defaultdict ( value ) return super () . annotate ( * args , ** kwargs ) change ( self , defaults = {}, ** kwargs ) Update and return number of rows that actually changed. For triggering on-change logic without fetching first. if qs.change(status=...): status actually changed qs.change({'last_modified': now}, status=...) last_modified only updated if status updated Parameters: Name Type Description Default defaults Mapping optional mapping which will be updated conditionally, as with update_or_create . {} Source code in model_values/__init__.py def change ( self , defaults : Mapping = {}, ** kwargs ) -> int : \"\"\"Update and return number of rows that actually changed. For triggering on-change logic without fetching first. ``if qs.change(status=...):`` status actually changed ``qs.change({'last_modified': now}, status=...)`` last_modified only updated if status updated Args: defaults: optional mapping which will be updated conditionally, as with ``update_or_create``. \"\"\" return self . exclude ( ** kwargs ) . update ( ** dict ( defaults , ** kwargs )) changed ( self , ** kwargs ) Return first mapping of fields and values which differ in the db. Also efficient enough to be used in boolean contexts, instead of exists . Source code in model_values/__init__.py def changed ( self , ** kwargs ) -> dict : \"\"\"Return first mapping of fields and values which differ in the db. Also efficient enough to be used in boolean contexts, instead of ``exists``. \"\"\" row = self . exclude ( ** kwargs ) . values ( * kwargs ) . first () or {} return { field : value for field , value in row . items () if value != kwargs [ field ]} exists ( self , count = 1 ) Return whether there are at least the specified number of rows. Source code in model_values/__init__.py def exists ( self , count : int = 1 ) -> bool : \"\"\"Return whether there are at least the specified number of rows.\"\"\" if count == 1 : return super () . exists () return ( self [: count ] . count () if self . _result_cache is None else len ( self )) >= count groupby ( self , * fields , ** annotations ) Return a grouped QuerySet _. The queryset is iterable in the same manner as itertools.groupby . Additionally the :meth: reduce functions will return annotated querysets. Source code in model_values/__init__.py def groupby ( self , * fields , ** annotations ) -> 'QuerySet' : \"\"\"Return a grouped `QuerySet`_. The queryset is iterable in the same manner as ``itertools.groupby``. Additionally the :meth:`reduce` functions will return annotated querysets. \"\"\" qs = self . annotate ( ** annotations ) qs . _groupby = fields + tuple ( annotations ) return qs items ( self , * fields , ** annotations ) Return annotated values_list . Source code in model_values/__init__.py def items ( self , * fields , ** annotations ) -> 'QuerySet' : \"\"\"Return annotated ``values_list``.\"\"\" return self . annotate ( ** annotations )[ fields + tuple ( annotations )] max ( self ) Max Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ ) mean ( self ) Avg Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ ) min ( self ) Min Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ ) reduce ( self , * funcs ) Return aggregated values, or an annotated QuerySet _ if :meth: groupby is in use. Parameters: Name Type Description Default *funcs aggregation function classes () Source code in model_values/__init__.py def reduce ( self , * funcs ): \"\"\"Return aggregated values, or an annotated `QuerySet`_ if :meth:`groupby` is in use. Args: *funcs: aggregation function classes \"\"\" funcs = [ func ( field ) for field , func in zip ( self . _fields , itertools . cycle ( funcs ))] if hasattr ( self , '_groupby' ): return self [ self . _groupby ] . annotate ( * funcs ) names = [ func . default_alias for func in funcs ] row = self . aggregate ( * funcs ) if self . _named : return collections . namedtuple ( 'Row' , names )( ** row ) return row [ names [ 0 ]] if self . _flat else tuple ( map ( row . __getitem__ , names )) sort_values ( self , reverse = False ) Return QuerySet _ ordered by selected values. Source code in model_values/__init__.py def sort_values ( self , reverse = False ) -> 'QuerySet' : \"\"\"Return `QuerySet`_ ordered by selected values.\"\"\" qs = self . order_by ( * self . _fields ) return qs . reverse () if reverse else qs std ( self ) StdDev Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ ) sum ( self ) Sum Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ ) update ( self , ** kwargs ) Update extended to also handle mapping values, as a Case _ expression. Parameters: Name Type Description Default **kwargs field={Q_obj: value, ...}, ... {} Source code in model_values/__init__.py def update ( self , ** kwargs ) -> int : \"\"\"Update extended to also handle mapping values, as a `Case`_ expression. Args: **kwargs: ``field={Q_obj: value, ...}, ...`` \"\"\" for field , value in kwargs . items (): if Case . isa ( value ): kwargs [ field ] = Case ( value , default = F ( field )) return super () . update ( ** kwargs ) value_counts ( self , alias = 'count' ) Return annotated value counts. Source code in model_values/__init__.py def value_counts ( self , alias : str = 'count' ) -> 'QuerySet' : \"\"\"Return annotated value counts.\"\"\" return self . items ( * self . _fields , ** { alias : F . count ()}) var ( self ) Variance Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ ) Note See source for available aggregate spatial functions if gis is configured. model_values.Manager __contains__ ( self , pk ) special Return whether primary key is present using exists . Source code in model_values/__init__.py def __contains__ ( self , pk ): \"\"\"Return whether primary key is present using ``exists``.\"\"\" return self [ pk ] . exists () __delitem__ ( self , pk ) special Delete row with primary key. Source code in model_values/__init__.py def __delitem__ ( self , pk ): \"\"\"Delete row with primary key.\"\"\" self [ pk ] . delete () __getitem__ ( self , pk ) special Return QuerySet _ which matches primary key. To encourage direct db access, instead of always using get and save. Source code in model_values/__init__.py def __getitem__ ( self , pk ) -> QuerySet : \"\"\"Return `QuerySet`_ which matches primary key. To encourage direct db access, instead of always using get and save. \"\"\" return self . filter ( pk = pk ) bulk_change ( self , field , data , key = 'pk' , conditional = False , ** kwargs ) Update changed rows with a minimal number of queries, by inverting the data to use pk__in . Parameters: Name Type Description Default field value column required data Mapping {pk: value, ...} required key str unique key column 'pk' conditional execute select query and single conditional update; False **kwargs additional fields to be updated {} Source code in model_values/__init__.py def bulk_change ( self , field , data : Mapping , key : str = 'pk' , conditional = False , ** kwargs ) -> int : \"\"\"Update changed rows with a minimal number of queries, by inverting the data to use ``pk__in``. Args: field: value column data: ``{pk: value, ...}`` key: unique key column conditional: execute select query and single conditional update; may be more efficient if the percentage of changed rows is relatively small **kwargs: additional fields to be updated \"\"\" if conditional : data = { pk : data [ pk ] for pk in self . bulk_changed ( field , data , key )} updates = collections . defaultdict ( list ) # type: dict for pk in data : updates [ data [ pk ]] . append ( pk ) if conditional : kwargs [ field ] = { F ( key ) . isin ( tuple ( updates [ value ])): value for value in updates } return self . filter ( F ( key ) . isin ( data )) . update ( ** kwargs ) count = 0 for value in updates : kwargs [ field ] = value count += self . filter (( F ( field ) != value ) & F ( key ) . isin ( updates [ value ])) . update ( ** kwargs ) return count bulk_changed ( self , field , data , key = 'pk' ) Return mapping of values which differ in the db. Parameters: Name Type Description Default field value column required data Mapping {pk: value, ...} required key str unique key column 'pk' Source code in model_values/__init__.py def bulk_changed ( self , field , data : Mapping , key : str = 'pk' ) -> dict : \"\"\"Return mapping of values which differ in the db. Args: field: value column data: ``{pk: value, ...}`` key: unique key column \"\"\" rows = self . filter ( F ( key ) . isin ( data ))[ key , field ] . iterator () return { pk : value for pk , value in rows if value != data [ pk ]} get_queryset ( self ) Return a new QuerySet object. Subclasses can override this method to customize the behavior of the Manager. Source code in model_values/__init__.py def get_queryset ( self ): return QuerySet ( self . model , Query ( self . model ), self . _db , self . _hints ) upsert ( self , defaults = {}, ** kwargs ) Update or insert returning number of rows or created object. Faster and safer than update_or_create . Supports combined expression updates by assuming the identity element on insert: F(...) + 1 . Parameters: Name Type Description Default defaults Mapping optional mapping which will be updated, as with update_or_create . {} Source code in model_values/__init__.py def upsert ( self , defaults : Mapping = {}, ** kwargs ) -> Union [ int , models . Model ]: \"\"\"Update or insert returning number of rows or created object. Faster and safer than ``update_or_create``. Supports combined expression updates by assuming the identity element on insert: ``F(...) + 1``. Args: defaults: optional mapping which will be updated, as with ``update_or_create``. \"\"\" update = getattr ( self . filter ( ** kwargs ), 'update' if defaults else 'count' ) for field , value in defaults . items (): expr = isinstance ( value , models . expressions . CombinedExpression ) kwargs [ field ] = value . rhs . value if expr else value try : with transaction . atomic (): return update ( ** defaults ) or self . create ( ** kwargs ) except IntegrityError : return update ( ** defaults ) model_values.Case Case expression from mapping of when conditionals. Parameters: Name Type Description Default conds {Q_obj: value, ...} required default optional default value or F object required output_field optional field defaults to registered types required model_values.classproperty A property bound to a class. model_values.EnumField ( enum , display = None , ** options ) Return a CharField or IntegerField with choices from given enum. By default, enum names and values are used as db values and display labels respectively, returning a CharField with computed max_length . Parameters: Name Type Description Default display Callable optional callable to transform enum names to display labels, thereby using enum values as db values and also supporting integers. None Source code in model_values/__init__.py def EnumField ( enum , display : Callable = None , ** options ) -> models . Field : \"\"\"Return a ``CharField`` or ``IntegerField`` with choices from given enum. By default, enum names and values are used as db values and display labels respectively, returning a ``CharField`` with computed ``max_length``. Args: display: optional callable to transform enum names to display labels, thereby using enum values as db values and also supporting integers. \"\"\" choices = tuple (( choice . name , choice . value ) for choice in enum ) if display is not None : choices = tuple (( choice . value , display ( choice . name )) for choice in enum ) try : max_length = max ( map ( len , dict ( choices ))) except TypeError : return models . IntegerField ( choices = choices , ** options ) return models . CharField ( max_length = max_length , choices = choices , ** options )","title":"Reference"},{"location":"reference/#model_values.Lookup","text":"Mixin for field lookups.","title":"Lookup"},{"location":"reference/#model_values.Lookup.is_valid","text":"Whether field isvalid .","title":"is_valid"},{"location":"reference/#model_values.Lookup.__ge__","text":"gte Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"__ge__()"},{"location":"reference/#model_values.Lookup.__gt__","text":"gt Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"__gt__()"},{"location":"reference/#model_values.Lookup.__le__","text":"lte Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"__le__()"},{"location":"reference/#model_values.Lookup.__lshift__","text":"left Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"__lshift__()"},{"location":"reference/#model_values.Lookup.__lt__","text":"lt Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"__lt__()"},{"location":"reference/#model_values.Lookup.__ne__","text":"ne Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"__ne__()"},{"location":"reference/#model_values.Lookup.__rshift__","text":"right Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"__rshift__()"},{"location":"reference/#model_values.Lookup.above","text":"strictly_above Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"above()"},{"location":"reference/#model_values.Lookup.below","text":"strictly_below Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"below()"},{"location":"reference/#model_values.Lookup.contained","text":"contained Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"contained()"},{"location":"reference/#model_values.Lookup.contains","text":"Return whether field contains the value. Options apply only to geom fields. Parameters: Name Type Description Default properly contains_properly False bb bounding box, bbcontains False Source code in model_values/__init__.py def contains ( self , value , properly = False , bb = False ): \"\"\"Return whether field `contains` the value. Options apply only to geom fields. Args: properly: `contains_properly` bb: bounding box, `bbcontains` \"\"\" properly = '_properly' * bool ( properly ) bb = 'bb' * bool ( bb ) return self . __eq__ ( value , f '__ { bb } contains { properly } ' )","title":"contains()"},{"location":"reference/#model_values.Lookup.coveredby","text":"coveredby Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"coveredby()"},{"location":"reference/#model_values.Lookup.covers","text":"covers Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"covers()"},{"location":"reference/#model_values.Lookup.crosses","text":"crosses Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"crosses()"},{"location":"reference/#model_values.Lookup.disjoint","text":"disjoint Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"disjoint()"},{"location":"reference/#model_values.Lookup.endswith","text":"endswith Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"endswith()"},{"location":"reference/#model_values.Lookup.equals","text":"equals Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"equals()"},{"location":"reference/#model_values.Lookup.icontains","text":"icontains Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"icontains()"},{"location":"reference/#model_values.Lookup.iendswith","text":"iendswith Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"iendswith()"},{"location":"reference/#model_values.Lookup.iexact","text":"iexact Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"iexact()"},{"location":"reference/#model_values.Lookup.intersects","text":"intersects Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"intersects()"},{"location":"reference/#model_values.Lookup.iregex","text":"iregex Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"iregex()"},{"location":"reference/#model_values.Lookup.isin","text":"in Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"isin()"},{"location":"reference/#model_values.Lookup.istartswith","text":"istartswith Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"istartswith()"},{"location":"reference/#model_values.Lookup.left","text":"left Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"left()"},{"location":"reference/#model_values.Lookup.overlaps","text":"Return whether field overlaps with geometry . Parameters: Name Type Description Default position overlaps_{left, right, above, below} '' bb bounding box, bboverlaps False Source code in model_values/__init__.py def overlaps ( self , geom , position = '' , bb = False ): \"\"\"Return whether field `overlaps` with geometry . Args: position: `overlaps_{left, right, above, below}` bb: bounding box, `bboverlaps` \"\"\" bb = 'bb' * bool ( bb ) return self . __eq__ ( geom , f '__ { bb } overlaps_ { position } ' . rstrip ( '_' ))","title":"overlaps()"},{"location":"reference/#model_values.Lookup.range","text":"range Source code in model_values/__init__.py def range ( self , * values ): \"\"\"range\"\"\" return self . __eq__ ( values , '__range' )","title":"range()"},{"location":"reference/#model_values.Lookup.regex","text":"regex Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"regex()"},{"location":"reference/#model_values.Lookup.relate","text":"relate Source code in model_values/__init__.py def relate ( self , * values ): \"\"\"relate\"\"\" return self . __eq__ ( values , '__relate' )","title":"relate()"},{"location":"reference/#model_values.Lookup.right","text":"right Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"right()"},{"location":"reference/#model_values.Lookup.startswith","text":"startswith Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"startswith()"},{"location":"reference/#model_values.Lookup.touches","text":"touches Source code in model_values/__init__.py return update_wrapper ( lambda self , value : self . __eq__ ( value , '__' + lookup ), lookup )","title":"touches()"},{"location":"reference/#model_values.Lookup.within","text":"Return whether field is within geometry. Parameters: Name Type Description Default distance dwithin None Source code in model_values/__init__.py def within ( self , geom , distance = None ): \"\"\"Return whether field is `within` geometry. Args: distance: `dwithin` \"\"\" if distance is None : return self . __eq__ ( geom , '__within' ) return self . __eq__ (( geom , distance ), '__dwithin' ) Note Spatial lookups require gis to be enabled.","title":"within()"},{"location":"reference/#model_values.F","text":"Create F , Q , and Func objects with expressions. F creation supported as attributes: F.user == F('user') , F.user.created == F('user__created') . Q lookups supported as methods or operators: F.text.iexact(...) == Q(text__iexact=...) , F.user.created >= ... == Q(user__created__gte=...) . Func objects also supported as methods: F.user.created.min() == Min('user__created') .","title":"F"},{"location":"reference/#model_values.F.__eq__","text":"Return Q object with lookup. Source code in model_values/__init__.py def __eq__ ( self , value , lookup : str = '' ) -> models . Q : \"\"\"Return ``Q`` object with lookup.\"\"\" if not lookup and type ( value ) is models . F : return self . name == value . name return models . Q ( ** { self . name + lookup : value })","title":"__eq__()"},{"location":"reference/#model_values.F.__getattr__","text":"Return new F _ object with chained attribute. Source code in model_values/__init__.py def __getattr__ ( self , name : str ) -> 'F' : \"\"\"Return new `F`_ object with chained attribute.\"\"\" return type ( self )( ' {} __ {} ' . format ( self . name , name ))","title":"__getattr__()"},{"location":"reference/#model_values.F.__getitem__","text":"Return field Substr or Right . Source code in model_values/__init__.py def __getitem__ ( self , slc : slice ) -> models . Func : \"\"\"Return field ``Substr`` or ``Right``.\"\"\" assert ( slc . stop or 0 ) >= 0 and slc . step is None start = slc . start or 0 if start < 0 : assert slc . stop is None return functions . Right ( self , - start ) size = slc . stop and max ( slc . stop - start , 0 ) return functions . Substr ( self , start + 1 , size )","title":"__getitem__()"},{"location":"reference/#model_values.F.__ne__","text":"Allow __ne=None lookup without custom queryset. Source code in model_values/__init__.py def __ne__ ( self , value ) -> models . Q : \"\"\"Allow __ne=None lookup without custom queryset.\"\"\" if value is None : return self . __eq__ ( False , '__isnull' ) return self . __eq__ ( value , '__ne' )","title":"__ne__()"},{"location":"reference/#model_values.F.find","text":"Return StrIndex with str.find semantics. Source code in model_values/__init__.py def find ( self , sub , ** extra ) -> models . Expression : \"\"\"Return ``StrIndex`` with ``str.find`` semantics.\"\"\" return functions . StrIndex ( self , Value ( sub ), ** extra ) - 1","title":"find()"},{"location":"reference/#model_values.F.ljust","text":"Return LPad with wrapped values. Source code in model_values/__init__.py def ljust ( self , width : int , fill = ' ' , ** extra ) -> models . Func : \"\"\"Return ``LPad`` with wrapped values.\"\"\" return functions . LPad ( self , width , Value ( fill ), ** extra )","title":"ljust()"},{"location":"reference/#model_values.F.log","text":"Return Log , by default Ln . Source code in model_values/__init__.py def log ( self , base = math . e , ** extra ) -> models . Func : \"\"\"Return ``Log``, by default ``Ln``.\"\"\" return functions . Log ( self , base , ** extra )","title":"log()"},{"location":"reference/#model_values.F.replace","text":"Return Replace with wrapped values. Source code in model_values/__init__.py def replace ( self , old , new = '' , ** extra ) -> models . Func : \"\"\"Return ``Replace`` with wrapped values.\"\"\" return functions . Replace ( self , Value ( old ), Value ( new ), ** extra )","title":"replace()"},{"location":"reference/#model_values.F.rjust","text":"Return RPad with wrapped values. Source code in model_values/__init__.py def rjust ( self , width : int , fill = ' ' , ** extra ) -> models . Func : \"\"\"Return ``RPad`` with wrapped values.\"\"\" return functions . RPad ( self , width , Value ( fill ), ** extra ) Note Since attributes are used for constructing F objects, there may be collisions between field names and methods. For example, name is a reserved attribute, but the usual constructor can still be used: F('name') . Note See source for available spatial functions if gis is configured.","title":"rjust()"},{"location":"reference/#model_values.QuerySet","text":"","title":"QuerySet"},{"location":"reference/#model_values.QuerySet.__add__","text":"add Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ )","title":"__add__()"},{"location":"reference/#model_values.QuerySet.__contains__","text":"Return whether value is present using exists . Source code in model_values/__init__.py def __contains__ ( self , value ): \"\"\"Return whether value is present using ``exists``.\"\"\" if self . _result_cache is None and self . _flat : return ( self == value ) . exists () return value in iter ( self )","title":"__contains__()"},{"location":"reference/#model_values.QuerySet.__eq__","text":"Return QuerySet _ filtered by comparison to given value. Source code in model_values/__init__.py def __eq__ ( self , value , lookup : str = '' ) -> 'QuerySet' : \"\"\"Return `QuerySet`_ filtered by comparison to given value.\"\"\" ( field ,) = self . _fields return self . filter ( ** { field + lookup : value })","title":"__eq__()"},{"location":"reference/#model_values.QuerySet.__getitem__","text":"Allow column access by field names, expressions, or F objects. qs[field] returns flat values_list qs[field, ...] returns tupled values_list qs[Q_obj] provisionally returns filtered QuerySet _ Source code in model_values/__init__.py def __getitem__ ( self , key ): \"\"\"Allow column access by field names, expressions, or ``F`` objects. ``qs[field]`` returns flat ``values_list`` ``qs[field, ...]`` returns tupled ``values_list`` ``qs[Q_obj]`` provisionally returns filtered `QuerySet`_ \"\"\" if isinstance ( key , tuple ): return self . values_list ( * map ( extract , key ), named = True ) key = extract ( key ) if isinstance ( key , ( str , models . Expression )): return self . values_list ( key , flat = True ) if isinstance ( key , models . Q ): return self . filter ( key ) return super () . __getitem__ ( key )","title":"__getitem__()"},{"location":"reference/#model_values.QuerySet.__iter__","text":"Iteration extended to support :meth: groupby . Source code in model_values/__init__.py def __iter__ ( self ): \"\"\"Iteration extended to support :meth:`groupby`.\"\"\" if not hasattr ( self , '_groupby' ): return super () . __iter__ () size = len ( self . _groupby ) rows = self [ self . _groupby + self . _fields ] . order_by ( * self . _groupby ) . iterator () groups = itertools . groupby ( rows , key = operator . itemgetter ( * range ( size ))) getter = operator . itemgetter ( size if self . _flat else slice ( size , None )) if self . _named : Row = collections . namedtuple ( 'Row' , self . _fields ) getter = lambda tup : Row ( * tup [ size :]) # noqa return (( key , map ( getter , values )) for key , values in groups )","title":"__iter__()"},{"location":"reference/#model_values.QuerySet.__mod__","text":"mod Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ )","title":"__mod__()"},{"location":"reference/#model_values.QuerySet.__mul__","text":"mul Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ )","title":"__mul__()"},{"location":"reference/#model_values.QuerySet.__pow__","text":"pow Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ )","title":"__pow__()"},{"location":"reference/#model_values.QuerySet.__setitem__","text":"Update a single column. Source code in model_values/__init__.py def __setitem__ ( self , key , value ): \"\"\"Update a single column.\"\"\" self . update ( ** { key : value })","title":"__setitem__()"},{"location":"reference/#model_values.QuerySet.__sub__","text":"sub Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ )","title":"__sub__()"},{"location":"reference/#model_values.QuerySet.__truediv__","text":"truediv Source code in model_values/__init__.py return update_wrapper ( lambda self , value : func ( models . F ( * self . _fields ), value ), func . __name__ )","title":"__truediv__()"},{"location":"reference/#model_values.QuerySet.annotate","text":"Annotate extended to also handle mapping values, as a Case _ expression. Parameters: Name Type Description Default **kwargs field={Q_obj: value, ...}, ... {} As a provisional feature, an optional default key may be specified. Source code in model_values/__init__.py def annotate ( self , * args , ** kwargs ) -> 'QuerySet' : \"\"\"Annotate extended to also handle mapping values, as a `Case`_ expression. Args: **kwargs: ``field={Q_obj: value, ...}, ...`` As a provisional feature, an optional ``default`` key may be specified. \"\"\" for field , value in kwargs . items (): if Case . isa ( value ): kwargs [ field ] = Case . defaultdict ( value ) return super () . annotate ( * args , ** kwargs )","title":"annotate()"},{"location":"reference/#model_values.QuerySet.change","text":"Update and return number of rows that actually changed. For triggering on-change logic without fetching first. if qs.change(status=...): status actually changed qs.change({'last_modified': now}, status=...) last_modified only updated if status updated Parameters: Name Type Description Default defaults Mapping optional mapping which will be updated conditionally, as with update_or_create . {} Source code in model_values/__init__.py def change ( self , defaults : Mapping = {}, ** kwargs ) -> int : \"\"\"Update and return number of rows that actually changed. For triggering on-change logic without fetching first. ``if qs.change(status=...):`` status actually changed ``qs.change({'last_modified': now}, status=...)`` last_modified only updated if status updated Args: defaults: optional mapping which will be updated conditionally, as with ``update_or_create``. \"\"\" return self . exclude ( ** kwargs ) . update ( ** dict ( defaults , ** kwargs ))","title":"change()"},{"location":"reference/#model_values.QuerySet.changed","text":"Return first mapping of fields and values which differ in the db. Also efficient enough to be used in boolean contexts, instead of exists . Source code in model_values/__init__.py def changed ( self , ** kwargs ) -> dict : \"\"\"Return first mapping of fields and values which differ in the db. Also efficient enough to be used in boolean contexts, instead of ``exists``. \"\"\" row = self . exclude ( ** kwargs ) . values ( * kwargs ) . first () or {} return { field : value for field , value in row . items () if value != kwargs [ field ]}","title":"changed()"},{"location":"reference/#model_values.QuerySet.exists","text":"Return whether there are at least the specified number of rows. Source code in model_values/__init__.py def exists ( self , count : int = 1 ) -> bool : \"\"\"Return whether there are at least the specified number of rows.\"\"\" if count == 1 : return super () . exists () return ( self [: count ] . count () if self . _result_cache is None else len ( self )) >= count","title":"exists()"},{"location":"reference/#model_values.QuerySet.groupby","text":"Return a grouped QuerySet _. The queryset is iterable in the same manner as itertools.groupby . Additionally the :meth: reduce functions will return annotated querysets. Source code in model_values/__init__.py def groupby ( self , * fields , ** annotations ) -> 'QuerySet' : \"\"\"Return a grouped `QuerySet`_. The queryset is iterable in the same manner as ``itertools.groupby``. Additionally the :meth:`reduce` functions will return annotated querysets. \"\"\" qs = self . annotate ( ** annotations ) qs . _groupby = fields + tuple ( annotations ) return qs","title":"groupby()"},{"location":"reference/#model_values.QuerySet.items","text":"Return annotated values_list . Source code in model_values/__init__.py def items ( self , * fields , ** annotations ) -> 'QuerySet' : \"\"\"Return annotated ``values_list``.\"\"\" return self . annotate ( ** annotations )[ fields + tuple ( annotations )]","title":"items()"},{"location":"reference/#model_values.QuerySet.max","text":"Max Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ )","title":"max()"},{"location":"reference/#model_values.QuerySet.mean","text":"Avg Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ )","title":"mean()"},{"location":"reference/#model_values.QuerySet.min","text":"Min Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ )","title":"min()"},{"location":"reference/#model_values.QuerySet.reduce","text":"Return aggregated values, or an annotated QuerySet _ if :meth: groupby is in use. Parameters: Name Type Description Default *funcs aggregation function classes () Source code in model_values/__init__.py def reduce ( self , * funcs ): \"\"\"Return aggregated values, or an annotated `QuerySet`_ if :meth:`groupby` is in use. Args: *funcs: aggregation function classes \"\"\" funcs = [ func ( field ) for field , func in zip ( self . _fields , itertools . cycle ( funcs ))] if hasattr ( self , '_groupby' ): return self [ self . _groupby ] . annotate ( * funcs ) names = [ func . default_alias for func in funcs ] row = self . aggregate ( * funcs ) if self . _named : return collections . namedtuple ( 'Row' , names )( ** row ) return row [ names [ 0 ]] if self . _flat else tuple ( map ( row . __getitem__ , names ))","title":"reduce()"},{"location":"reference/#model_values.QuerySet.sort_values","text":"Return QuerySet _ ordered by selected values. Source code in model_values/__init__.py def sort_values ( self , reverse = False ) -> 'QuerySet' : \"\"\"Return `QuerySet`_ ordered by selected values.\"\"\" qs = self . order_by ( * self . _fields ) return qs . reverse () if reverse else qs","title":"sort_values()"},{"location":"reference/#model_values.QuerySet.std","text":"StdDev Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ )","title":"std()"},{"location":"reference/#model_values.QuerySet.sum","text":"Sum Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ )","title":"sum()"},{"location":"reference/#model_values.QuerySet.update","text":"Update extended to also handle mapping values, as a Case _ expression. Parameters: Name Type Description Default **kwargs field={Q_obj: value, ...}, ... {} Source code in model_values/__init__.py def update ( self , ** kwargs ) -> int : \"\"\"Update extended to also handle mapping values, as a `Case`_ expression. Args: **kwargs: ``field={Q_obj: value, ...}, ...`` \"\"\" for field , value in kwargs . items (): if Case . isa ( value ): kwargs [ field ] = Case ( value , default = F ( field )) return super () . update ( ** kwargs )","title":"update()"},{"location":"reference/#model_values.QuerySet.value_counts","text":"Return annotated value counts. Source code in model_values/__init__.py def value_counts ( self , alias : str = 'count' ) -> 'QuerySet' : \"\"\"Return annotated value counts.\"\"\" return self . items ( * self . _fields , ** { alias : F . count ()})","title":"value_counts()"},{"location":"reference/#model_values.QuerySet.var","text":"Variance Source code in model_values/__init__.py return update_wrapper ( lambda self : self . reduce ( func ), func . __name__ ) Note See source for available aggregate spatial functions if gis is configured.","title":"var()"},{"location":"reference/#model_values.Manager","text":"","title":"Manager"},{"location":"reference/#model_values.Manager.__contains__","text":"Return whether primary key is present using exists . Source code in model_values/__init__.py def __contains__ ( self , pk ): \"\"\"Return whether primary key is present using ``exists``.\"\"\" return self [ pk ] . exists ()","title":"__contains__()"},{"location":"reference/#model_values.Manager.__delitem__","text":"Delete row with primary key. Source code in model_values/__init__.py def __delitem__ ( self , pk ): \"\"\"Delete row with primary key.\"\"\" self [ pk ] . delete ()","title":"__delitem__()"},{"location":"reference/#model_values.Manager.__getitem__","text":"Return QuerySet _ which matches primary key. To encourage direct db access, instead of always using get and save. Source code in model_values/__init__.py def __getitem__ ( self , pk ) -> QuerySet : \"\"\"Return `QuerySet`_ which matches primary key. To encourage direct db access, instead of always using get and save. \"\"\" return self . filter ( pk = pk )","title":"__getitem__()"},{"location":"reference/#model_values.Manager.bulk_change","text":"Update changed rows with a minimal number of queries, by inverting the data to use pk__in . Parameters: Name Type Description Default field value column required data Mapping {pk: value, ...} required key str unique key column 'pk' conditional execute select query and single conditional update; False **kwargs additional fields to be updated {} Source code in model_values/__init__.py def bulk_change ( self , field , data : Mapping , key : str = 'pk' , conditional = False , ** kwargs ) -> int : \"\"\"Update changed rows with a minimal number of queries, by inverting the data to use ``pk__in``. Args: field: value column data: ``{pk: value, ...}`` key: unique key column conditional: execute select query and single conditional update; may be more efficient if the percentage of changed rows is relatively small **kwargs: additional fields to be updated \"\"\" if conditional : data = { pk : data [ pk ] for pk in self . bulk_changed ( field , data , key )} updates = collections . defaultdict ( list ) # type: dict for pk in data : updates [ data [ pk ]] . append ( pk ) if conditional : kwargs [ field ] = { F ( key ) . isin ( tuple ( updates [ value ])): value for value in updates } return self . filter ( F ( key ) . isin ( data )) . update ( ** kwargs ) count = 0 for value in updates : kwargs [ field ] = value count += self . filter (( F ( field ) != value ) & F ( key ) . isin ( updates [ value ])) . update ( ** kwargs ) return count","title":"bulk_change()"},{"location":"reference/#model_values.Manager.bulk_changed","text":"Return mapping of values which differ in the db. Parameters: Name Type Description Default field value column required data Mapping {pk: value, ...} required key str unique key column 'pk' Source code in model_values/__init__.py def bulk_changed ( self , field , data : Mapping , key : str = 'pk' ) -> dict : \"\"\"Return mapping of values which differ in the db. Args: field: value column data: ``{pk: value, ...}`` key: unique key column \"\"\" rows = self . filter ( F ( key ) . isin ( data ))[ key , field ] . iterator () return { pk : value for pk , value in rows if value != data [ pk ]}","title":"bulk_changed()"},{"location":"reference/#model_values.Manager.get_queryset","text":"Return a new QuerySet object. Subclasses can override this method to customize the behavior of the Manager. Source code in model_values/__init__.py def get_queryset ( self ): return QuerySet ( self . model , Query ( self . model ), self . _db , self . _hints )","title":"get_queryset()"},{"location":"reference/#model_values.Manager.upsert","text":"Update or insert returning number of rows or created object. Faster and safer than update_or_create . Supports combined expression updates by assuming the identity element on insert: F(...) + 1 . Parameters: Name Type Description Default defaults Mapping optional mapping which will be updated, as with update_or_create . {} Source code in model_values/__init__.py def upsert ( self , defaults : Mapping = {}, ** kwargs ) -> Union [ int , models . Model ]: \"\"\"Update or insert returning number of rows or created object. Faster and safer than ``update_or_create``. Supports combined expression updates by assuming the identity element on insert: ``F(...) + 1``. Args: defaults: optional mapping which will be updated, as with ``update_or_create``. \"\"\" update = getattr ( self . filter ( ** kwargs ), 'update' if defaults else 'count' ) for field , value in defaults . items (): expr = isinstance ( value , models . expressions . CombinedExpression ) kwargs [ field ] = value . rhs . value if expr else value try : with transaction . atomic (): return update ( ** defaults ) or self . create ( ** kwargs ) except IntegrityError : return update ( ** defaults )","title":"upsert()"},{"location":"reference/#model_values.Case","text":"Case expression from mapping of when conditionals. Parameters: Name Type Description Default conds {Q_obj: value, ...} required default optional default value or F object required output_field optional field defaults to registered types required","title":"Case"},{"location":"reference/#model_values.classproperty","text":"A property bound to a class.","title":"classproperty"},{"location":"reference/#model_values.EnumField","text":"Return a CharField or IntegerField with choices from given enum. By default, enum names and values are used as db values and display labels respectively, returning a CharField with computed max_length . Parameters: Name Type Description Default display Callable optional callable to transform enum names to display labels, thereby using enum values as db values and also supporting integers. None Source code in model_values/__init__.py def EnumField ( enum , display : Callable = None , ** options ) -> models . Field : \"\"\"Return a ``CharField`` or ``IntegerField`` with choices from given enum. By default, enum names and values are used as db values and display labels respectively, returning a ``CharField`` with computed ``max_length``. Args: display: optional callable to transform enum names to display labels, thereby using enum values as db values and also supporting integers. \"\"\" choices = tuple (( choice . name , choice . value ) for choice in enum ) if display is not None : choices = tuple (( choice . value , display ( choice . name )) for choice in enum ) try : max_length = max ( map ( len , dict ( choices ))) except TypeError : return models . IntegerField ( choices = choices , ** options ) return models . CharField ( max_length = max_length , choices = choices , ** options )","title":"EnumField()"}]}